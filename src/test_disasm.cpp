#include "disassembler.cpp"
#include <vector>

int main()
{
    // Test ROM with representative samples from each opcode range
    std::vector<uint8_t> rom = {
        // 0x00-0x0F: Basic operations
        0x00,             // NOP
        0x01, 0x34, 0x12, // LD BC, $1234
        0x06, 0xAA,       // LD B, $AA
        0x0E, 0x55,       // LD C, $55
        
        // 0x10-0x1F: More loads and operations
        0x10, 0x00,       // STOP
        0x11, 0x00, 0xC0, // LD DE, $C000
        0x18, 0x05,       // JR $05
        
        // 0x20-0x2F: Jump and HL operations
        0x20, 0x03,       // JR NZ, $03
        0x21, 0x00, 0x80, // LD HL, $8000
        0x22,             // LD (HL+), A
        0x2A,             // LD A, (HL+)
        0x2E, 0xFF,       // LD L, $FF
        
        // 0x30-0x3F: Stack and accumulator ops
        0x31, 0xFE, 0xFF, // LD SP, $FFFE
        0x32,             // LD (HL-), A
        0x3A,             // LD A, (HL-)
        0x3E, 0x42,       // LD A, $42
        
        // 0x40-0x7F: LD instructions (sample)
        0x40,             // LD B, B
        0x47,             // LD B, A
        0x4F,             // LD C, A
        0x57,             // LD D, A
        0x5F,             // LD E, A
        0x67,             // LD H, A
        0x6F,             // LD L, A
        0x77,             // LD (HL), A
        0x7E,             // LD A, (HL)
        0x7F,             // LD A, A
        
        // 0x80-0x8F: ADD/ADC operations
        0x80,             // ADD A, B
        0x86,             // ADD A, (HL)
        0x87,             // ADD A, A
        0x88,             // ADC A, B
        0xC6, 0x10,       // ADD A, $10
        0xCE, 0x20,       // ADC A, $20
        
        // 0x90-0x9F: SUB/SBC operations
        0x90,             // SUB B
        0x96,             // SUB (HL)
        0x97,             // SUB A
        0x98,             // SBC A, B
        0xD6, 0x30,       // SUB $30
        0xDE, 0x40,       // SBC A, $40
        
        // 0xA0-0xAF: Logical operations
        0xA0,             // AND B
        0xA7,             // AND A
        0xA8,             // XOR B
        0xAF,             // XOR A
        0xE6, 0x0F,       // AND $0F
        0xEE, 0xF0,       // XOR $F0
        
        // 0xB0-0xBF: OR/CP operations
        0xB0,             // OR B
        0xB7,             // OR A
        0xB8,             // CP B
        0xBF,             // CP A
        0xF6, 0x80,       // OR $80
        0xFE, 0x00,       // CP $00
        
        // 0xC0-0xCF: Control flow
        0xC0,             // RET NZ
        0xC1,             // POP BC
        0xC3, 0x00, 0x01, // JP $0100
        0xC5,             // PUSH BC
        0xC7,             // RST 00H
        0xC8,             // RET Z
        0xC9,             // RET
        0xCD, 0x50, 0x01, // CALL $0150
        0xCF,             // RST 08H
        
        // 0xD0-0xDF: More control flow
        0xD0,             // RET NC
        0xD1,             // POP DE
        0xD5,             // PUSH DE
        0xD7,             // RST 10H
        0xD8,             // RET C
        0xD9,             // RETI
        0xDF,             // RST 18H
        
        // 0xE0-0xEF: I/O and special ops
        0xE0, 0x44,       // LDH ($44), A
        0xE1,             // POP HL
        0xE2,             // LD (C), A
        0xE5,             // PUSH HL
        0xE7,             // RST 20H
        0xE8, 0x08,       // ADD SP, $08
        0xE9,             // JP (HL)
        0xEA, 0x00, 0xC0, // LD ($C000), A
        0xEF,             // RST 28H
        
        // 0xF0-0xFF: Final ops
        0xF0, 0x40,       // LDH A, ($40)
        0xF1,             // POP AF
        0xF2,             // LD A, (C)
        0xF3,             // DI
        0xF5,             // PUSH AF
        0xF7,             // RST 30H
        0xF8, 0xF8,       // LD HL, SP+$F8
        0xF9,             // LD SP, HL
        0xFA, 0x00, 0xC1, // LD A, ($C100)
        0xFB,             // EI
        0xFF,             // RST 38H
        
        // CB-prefixed instructions: RLC (all 8 registers)
        0xCB, 0x00,       // RLC B
        0xCB, 0x01,       // RLC C
        0xCB, 0x02,       // RLC D
        0xCB, 0x03,       // RLC E
        0xCB, 0x04,       // RLC H
        0xCB, 0x05,       // RLC L
        0xCB, 0x06,       // RLC (HL)
        0xCB, 0x07,       // RLC A
        
        // RRC (all 8 registers)
        0xCB, 0x08,       // RRC B
        0xCB, 0x09,       // RRC C
        0xCB, 0x0A,       // RRC D
        0xCB, 0x0B,       // RRC E
        0xCB, 0x0C,       // RRC H
        0xCB, 0x0D,       // RRC L
        0xCB, 0x0E,       // RRC (HL)
        0xCB, 0x0F,       // RRC A
        
        // RL (all 8 registers)
        0xCB, 0x10,       // RL B
        0xCB, 0x11,       // RL C
        0xCB, 0x12,       // RL D
        0xCB, 0x13,       // RL E
        0xCB, 0x14,       // RL H
        0xCB, 0x15,       // RL L
        0xCB, 0x16,       // RL (HL)
        0xCB, 0x17,       // RL A
        
        // RR (all 8 registers)
        0xCB, 0x18,       // RR B
        0xCB, 0x19,       // RR C
        0xCB, 0x1A,       // RR D
        0xCB, 0x1B,       // RR E
        0xCB, 0x1C,       // RR H
        0xCB, 0x1D,       // RR L
        0xCB, 0x1E,       // RR (HL)
        0xCB, 0x1F,       // RR A
        
        // SLA (all 8 registers)
        0xCB, 0x20,       // SLA B
        0xCB, 0x21,       // SLA C
        0xCB, 0x22,       // SLA D
        0xCB, 0x23,       // SLA E
        0xCB, 0x24,       // SLA H
        0xCB, 0x25,       // SLA L
        0xCB, 0x26,       // SLA (HL)
        0xCB, 0x27,       // SLA A
        
        // SRA (all 8 registers)
        0xCB, 0x28,       // SRA B
        0xCB, 0x29,       // SRA C
        0xCB, 0x2A,       // SRA D
        0xCB, 0x2B,       // SRA E
        0xCB, 0x2C,       // SRA H
        0xCB, 0x2D,       // SRA L
        0xCB, 0x2E,       // SRA (HL)
        0xCB, 0x2F,       // SRA A
        
        // SWAP (all 8 registers)
        0xCB, 0x30,       // SWAP B
        0xCB, 0x31,       // SWAP C
        0xCB, 0x32,       // SWAP D
        0xCB, 0x33,       // SWAP E
        0xCB, 0x34,       // SWAP H
        0xCB, 0x35,       // SWAP L
        0xCB, 0x36,       // SWAP (HL)
        0xCB, 0x37,       // SWAP A
        
        // SRL (all 8 registers)
        0xCB, 0x38,       // SRL B
        0xCB, 0x39,       // SRL C
        0xCB, 0x3A,       // SRL D
        0xCB, 0x3B,       // SRL E
        0xCB, 0x3C,       // SRL H
        0xCB, 0x3D,       // SRL L
        0xCB, 0x3E,       // SRL (HL)
        0xCB, 0x3F,       // SRL A
        
        // CB-prefixed: BIT operations (all 8 bits × 8 registers = 64 instructions)
        0xCB, 0x40, 0xCB, 0x41, 0xCB, 0x42, 0xCB, 0x43, 0xCB, 0x44, 0xCB, 0x45, 0xCB, 0x46, 0xCB, 0x47, // BIT 0, B/C/D/E/H/L/(HL)/A
        0xCB, 0x48, 0xCB, 0x49, 0xCB, 0x4A, 0xCB, 0x4B, 0xCB, 0x4C, 0xCB, 0x4D, 0xCB, 0x4E, 0xCB, 0x4F, // BIT 1, B/C/D/E/H/L/(HL)/A
        0xCB, 0x50, 0xCB, 0x51, 0xCB, 0x52, 0xCB, 0x53, 0xCB, 0x54, 0xCB, 0x55, 0xCB, 0x56, 0xCB, 0x57, // BIT 2, B/C/D/E/H/L/(HL)/A
        0xCB, 0x58, 0xCB, 0x59, 0xCB, 0x5A, 0xCB, 0x5B, 0xCB, 0x5C, 0xCB, 0x5D, 0xCB, 0x5E, 0xCB, 0x5F, // BIT 3, B/C/D/E/H/L/(HL)/A
        0xCB, 0x60, 0xCB, 0x61, 0xCB, 0x62, 0xCB, 0x63, 0xCB, 0x64, 0xCB, 0x65, 0xCB, 0x66, 0xCB, 0x67, // BIT 4, B/C/D/E/H/L/(HL)/A
        0xCB, 0x68, 0xCB, 0x69, 0xCB, 0x6A, 0xCB, 0x6B, 0xCB, 0x6C, 0xCB, 0x6D, 0xCB, 0x6E, 0xCB, 0x6F, // BIT 5, B/C/D/E/H/L/(HL)/A
        0xCB, 0x70, 0xCB, 0x71, 0xCB, 0x72, 0xCB, 0x73, 0xCB, 0x74, 0xCB, 0x75, 0xCB, 0x76, 0xCB, 0x77, // BIT 6, B/C/D/E/H/L/(HL)/A
        0xCB, 0x78, 0xCB, 0x79, 0xCB, 0x7A, 0xCB, 0x7B, 0xCB, 0x7C, 0xCB, 0x7D, 0xCB, 0x7E, 0xCB, 0x7F, // BIT 7, B/C/D/E/H/L/(HL)/A
        
        // CB-prefixed: RES operations (all 8 bits × 8 registers = 64 instructions)
        0xCB, 0x80, 0xCB, 0x81, 0xCB, 0x82, 0xCB, 0x83, 0xCB, 0x84, 0xCB, 0x85, 0xCB, 0x86, 0xCB, 0x87, // RES 0, B/C/D/E/H/L/(HL)/A
        0xCB, 0x88, 0xCB, 0x89, 0xCB, 0x8A, 0xCB, 0x8B, 0xCB, 0x8C, 0xCB, 0x8D, 0xCB, 0x8E, 0xCB, 0x8F, // RES 1, B/C/D/E/H/L/(HL)/A
        0xCB, 0x90, 0xCB, 0x91, 0xCB, 0x92, 0xCB, 0x93, 0xCB, 0x94, 0xCB, 0x95, 0xCB, 0x96, 0xCB, 0x97, // RES 2, B/C/D/E/H/L/(HL)/A
        0xCB, 0x98, 0xCB, 0x99, 0xCB, 0x9A, 0xCB, 0x9B, 0xCB, 0x9C, 0xCB, 0x9D, 0xCB, 0x9E, 0xCB, 0x9F, // RES 3, B/C/D/E/H/L/(HL)/A
        0xCB, 0xA0, 0xCB, 0xA1, 0xCB, 0xA2, 0xCB, 0xA3, 0xCB, 0xA4, 0xCB, 0xA5, 0xCB, 0xA6, 0xCB, 0xA7, // RES 4, B/C/D/E/H/L/(HL)/A
        0xCB, 0xA8, 0xCB, 0xA9, 0xCB, 0xAA, 0xCB, 0xAB, 0xCB, 0xAC, 0xCB, 0xAD, 0xCB, 0xAE, 0xCB, 0xAF, // RES 5, B/C/D/E/H/L/(HL)/A
        0xCB, 0xB0, 0xCB, 0xB1, 0xCB, 0xB2, 0xCB, 0xB3, 0xCB, 0xB4, 0xCB, 0xB5, 0xCB, 0xB6, 0xCB, 0xB7, // RES 6, B/C/D/E/H/L/(HL)/A
        0xCB, 0xB8, 0xCB, 0xB9, 0xCB, 0xBA, 0xCB, 0xBB, 0xCB, 0xBC, 0xCB, 0xBD, 0xCB, 0xBE, 0xCB, 0xBF, // RES 7, B/C/D/E/H/L/(HL)/A
        
        // CB-prefixed: SET operations (all 8 bits × 8 registers = 64 instructions)
        0xCB, 0xC0, 0xCB, 0xC1, 0xCB, 0xC2, 0xCB, 0xC3, 0xCB, 0xC4, 0xCB, 0xC5, 0xCB, 0xC6, 0xCB, 0xC7, // SET 0, B/C/D/E/H/L/(HL)/A
        0xCB, 0xC8, 0xCB, 0xC9, 0xCB, 0xCA, 0xCB, 0xCB, 0xCB, 0xCC, 0xCB, 0xCD, 0xCB, 0xCE, 0xCB, 0xCF, // SET 1, B/C/D/E/H/L/(HL)/A
        0xCB, 0xD0, 0xCB, 0xD1, 0xCB, 0xD2, 0xCB, 0xD3, 0xCB, 0xD4, 0xCB, 0xD5, 0xCB, 0xD6, 0xCB, 0xD7, // SET 2, B/C/D/E/H/L/(HL)/A
        0xCB, 0xD8, 0xCB, 0xD9, 0xCB, 0xDA, 0xCB, 0xDB, 0xCB, 0xDC, 0xCB, 0xDD, 0xCB, 0xDE, 0xCB, 0xDF, // SET 3, B/C/D/E/H/L/(HL)/A
        0xCB, 0xE0, 0xCB, 0xE1, 0xCB, 0xE2, 0xCB, 0xE3, 0xCB, 0xE4, 0xCB, 0xE5, 0xCB, 0xE6, 0xCB, 0xE7, // SET 4, B/C/D/E/H/L/(HL)/A
        0xCB, 0xE8, 0xCB, 0xE9, 0xCB, 0xEA, 0xCB, 0xEB, 0xCB, 0xEC, 0xCB, 0xED, 0xCB, 0xEE, 0xCB, 0xEF, // SET 5, B/C/D/E/H/L/(HL)/A
        0xCB, 0xF0, 0xCB, 0xF1, 0xCB, 0xF2, 0xCB, 0xF3, 0xCB, 0xF4, 0xCB, 0xF5, 0xCB, 0xF6, 0xCB, 0xF7, // SET 6, B/C/D/E/H/L/(HL)/A
        0xCB, 0xF8, 0xCB, 0xF9, 0xCB, 0xFA, 0xCB, 0xFB, 0xCB, 0xFC, 0xCB, 0xFD, 0xCB, 0xFE, 0xCB, 0xFF, // SET 7, B/C/D/E/H/L/(HL)/A
    };

    std::println("Game Boy Disassembler Test");
    std::println("Testing ALL {} bytes - Complete opcode coverage\n", rom.size());
    std::println("Standard opcodes: ~121 bytes");
    std::println("CB-prefixed opcodes: All 256 CB instructions (512 bytes)\n");
    disassembler::print_disassembly(rom, 0, 350);

    return 0;
}
