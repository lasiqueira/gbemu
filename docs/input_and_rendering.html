<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Input & Rendering - Game Boy Emulator</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>Game Boy Emulator</h1>
        <p>A C++ Game Boy emulator development journey</p>
    </header>

    <nav class="page-nav">
        <a href="instructions_part2.html">← Instructions - Part 2</a>
        <span class="current">Input & Rendering</span>
        <a href="index.html">Index →</a>
    </nav>

    <main>
        <article class="content">
        <h2>Input & Rendering Systems</h2>
        <p><em>Implementing the Game Boy's joypad and graphics subsystems</em></p>

        <div style="text-align: center; margin: 2em 0;">
            <img src="images/tetris_title_debug.png" alt="Tetris Title Screen" style="max-width: 100%; border: 1px solid #444; border-radius: 4px;">
            <p style="font-style: italic; color: #888; margin-top: 0.5em;">Tetris title screen demonstrating all rendering layers (background, window, sprites) with debug info</p>
        </div>

        <section>
            <h2>Part 1: Joypad Input System</h2>
            
            <h3>Overview</h3>
            <p>The Game Boy has 8 buttons organized into two groups:</p>
            <ul>
                <li><strong>Direction Keys:</strong> Up, Down, Left, Right</li>
                <li><strong>Action Buttons:</strong> A, B, Select, Start</li>
            </ul>
            
            <p>Input is accessed through a single I/O register at <strong>0xFF00 (JOYP)</strong> that multiplexes both groups.</p>

            <h3>JOYP Register (0xFF00)</h3>
            <p>The register layout is:</p>
            <pre><code>Bit 7-6: Not used (always 1)
Bit 5:   Select Action buttons   (0=select)
Bit 4:   Select Direction buttons (0=select)
Bit 3:   Down  or Start   (0=pressed, 1=released)
Bit 2:   Up    or Select  (0=pressed, 1=released)
Bit 1:   Left  or B       (0=pressed, 1=released)
Bit 0:   Right or A       (0=pressed, 1=released)</code></pre>

            <p><strong>Important:</strong> Button states are active-low (0 = pressed, 1 = released).</p>

            <h3>Reading Input</h3>
            <p>To read the joypad state, games must:</p>
            <ol>
                <li>Write to JOYP to select button group (clear bit 4 or 5)</li>
                <li>Read from JOYP to get button states in bits 0-3</li>
                <li>Repeat for the other button group if needed</li>
            </ol>

            <h3>Memory-Side Implementation</h3>
            <p>The emulator stores button states in an 8-bit variable and returns the appropriate bits when JOYP is read:</p>

            <pre><code>// In Memory struct
uint8_t joypad_state;  // Bits 0-3: A,B,Select,Start; Bits 4-7: Right,Left,Up,Down

// Reading JOYP (0xFF00)
if (addr == 0xFF00) {
    uint8_t joyp = io[0];
    uint8_t result = 0xC0; // Bits 6-7 always set
    
    if (!(joyp & 0x10)) {
        // Direction keys selected
        result |= 0x10;
        result |= (joypad_state >> 4) & 0x0F; // Bits 4-7 → 0-3
    }
    else if (!(joyp & 0x20)) {
        // Action buttons selected
        result |= 0x20;
        result |= joypad_state & 0x0F; // Bits 0-3
    }
    else {
        // Nothing selected
        result |= 0x30;
        result |= 0x0F; // All released
    }
    
    return result;
}</code></pre>

            <h3>SDL Input Mapping</h3>
            <p>SDL keyboard events are mapped to Game Boy buttons:</p>

            <table>
                <thead>
                    <tr>
                        <th>Game Boy Button</th>
                        <th>Keyboard Key</th>
                        <th>Bit Position</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>A</td>
                        <td>Z</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td>B</td>
                        <td>X</td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td>Select</td>
                        <td>Shift</td>
                        <td>2</td>
                    </tr>
                    <tr>
                        <td>Start</td>
                        <td>Enter</td>
                        <td>3</td>
                    </tr>
                    <tr>
                        <td>Right</td>
                        <td>→</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>Left</td>
                        <td>←</td>
                        <td>5</td>
                    </tr>
                    <tr>
                        <td>Up</td>
                        <td>↑</td>
                        <td>6</td>
                    </tr>
                    <tr>
                        <td>Down</td>
                        <td>↓</td>
                        <td>7</td>
                    </tr>
                </tbody>
            </table>

            <h3>Input Handler Implementation</h3>
            <pre><code>void handle_input(SDL_Event& event, GameBoy& gameboy)
{
    if (event.type != SDL_EVENT_KEY_DOWN && event.type != SDL_EVENT_KEY_UP)
        return;
    
    bool pressed = (event.type == SDL_EVENT_KEY_DOWN);
    uint8_t& joypad = gameboy.memory.joypad_state;
    
    switch (event.key.key)
    {
        case SDLK_Z:      // A button
            if (pressed) joypad &= ~0x01; else joypad |= 0x01;
            break;
        case SDLK_X:      // B button
            if (pressed) joypad &= ~0x02; else joypad |= 0x02;
            break;
        case SDLK_RSHIFT: // Select
        case SDLK_LSHIFT:
            if (pressed) joypad &= ~0x04; else joypad |= 0x04;
            break;
        case SDLK_RETURN: // Start
            if (pressed) joypad &= ~0x08; else joypad |= 0x08;
            break;
        case SDLK_RIGHT:  // Right
            if (pressed) joypad &= ~0x10; else joypad |= 0x10;
            break;
        case SDLK_LEFT:   // Left
            if (pressed) joypad &= ~0x20; else joypad |= 0x20;
            break;
        case SDLK_UP:     // Up
            if (pressed) joypad &= ~0x40; else joypad |= 0x40;
            break;
        case SDLK_DOWN:   // Down
            if (pressed) joypad &= ~0x80; else joypad |= 0x80;
            break;
    }
}</code></pre>

            <h3>Gamepad/Controller Support</h3>
            <p>The emulator supports physical game controllers (Xbox, PlayStation, Nintendo Pro) using SDL's unified gamepad API. Controllers are automatically detected and can be hot-plugged during gameplay.</p>

            <h4>Supported Controllers</h4>
            <ul>
                <li><strong>Xbox Controllers:</strong> Xbox One, Xbox Series X|S</li>
                <li><strong>PlayStation Controllers:</strong> DualShock 4, DualSense</li>
                <li><strong>Nintendo Controllers:</strong> Switch Pro Controller</li>
                <li><strong>Generic Controllers:</strong> Any controller recognized by SDL's gamepad database</li>
            </ul>

            <h4>Button Mapping</h4>
            <p>SDL gamepad buttons are mapped to Game Boy buttons as follows:</p>

            <table>
                <thead>
                    <tr>
                        <th>Game Boy Button</th>
                        <th>SDL Gamepad Button</th>
                        <th>Xbox</th>
                        <th>PlayStation</th>
                        <th>Switch</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>A</td>
                        <td>SOUTH</td>
                        <td>A</td>
                        <td>✕ (Cross)</td>
                        <td>B</td>
                    </tr>
                    <tr>
                        <td>B</td>
                        <td>EAST</td>
                        <td>B</td>
                        <td>○ (Circle)</td>
                        <td>A</td>
                    </tr>
                    <tr>
                        <td>Select</td>
                        <td>BACK</td>
                        <td>View/Back</td>
                        <td>Share</td>
                        <td>− (Minus)</td>
                    </tr>
                    <tr>
                        <td>Start</td>
                        <td>START</td>
                        <td>Menu/Start</td>
                        <td>Options</td>
                        <td>+ (Plus)</td>
                    </tr>
                    <tr>
                        <td>D-Pad</td>
                        <td>DPAD_*</td>
                        <td>D-Pad</td>
                        <td>D-Pad</td>
                        <td>D-Pad</td>
                    </tr>
                </tbody>
            </table>

            <h4>Gamepad Initialization</h4>
            <pre><code>// Initialize SDL with gamepad support
SDL_Init(SDL_INIT_VIDEO | SDL_INIT_GAMEPAD);

// Open the first available gamepad
SDL_Gamepad* gamepad = nullptr;
int num_joysticks = 0;
SDL_JoystickID* joysticks = SDL_GetGamepads(&num_joysticks);
if (num_joysticks > 0) {
    gamepad = SDL_OpenGamepad(joysticks[0]);
    if (gamepad) {
        std::println("Gamepad connected: {}", SDL_GetGamepadName(gamepad));
    }
}
SDL_free(joysticks);</code></pre>

            <h4>Gamepad Input Handler</h4>
            <pre><code>void handle_gamepad_input(SDL_Event& event, GameBoy& gameboy)
{
    if (event.type != SDL_EVENT_GAMEPAD_BUTTON_DOWN && 
        event.type != SDL_EVENT_GAMEPAD_BUTTON_UP)
        return;
    
    bool pressed = (event.type == SDL_EVENT_GAMEPAD_BUTTON_DOWN);
    uint8_t& joypad = gameboy.memory.joypad_state;
    
    switch (event.gbutton.button)
    {
        case SDL_GAMEPAD_BUTTON_SOUTH:  // A
            if (pressed) joypad &= ~0x01; else joypad |= 0x01;
            break;
        case SDL_GAMEPAD_BUTTON_EAST:   // B
            if (pressed) joypad &= ~0x02; else joypad |= 0x02;
            break;
        case SDL_GAMEPAD_BUTTON_BACK:   // Select
            if (pressed) joypad &= ~0x04; else joypad |= 0x04;
            break;
        case SDL_GAMEPAD_BUTTON_START:  // Start
            if (pressed) joypad &= ~0x08; else joypad |= 0x08;
            break;
        case SDL_GAMEPAD_BUTTON_DPAD_RIGHT:
            if (pressed) joypad &= ~0x10; else joypad |= 0x10;
            break;
        case SDL_GAMEPAD_BUTTON_DPAD_LEFT:
            if (pressed) joypad &= ~0x20; else joypad |= 0x20;
            break;
        case SDL_GAMEPAD_BUTTON_DPAD_UP:
            if (pressed) joypad &= ~0x40; else joypad |= 0x40;
            break;
        case SDL_GAMEPAD_BUTTON_DPAD_DOWN:
            if (pressed) joypad &= ~0x80; else joypad |= 0x80;
            break;
    }
}</code></pre>

            <h4>Hot-Plugging Support</h4>
            <p>The emulator handles controller connect/disconnect events during gameplay:</p>

            <pre><code>// In main event loop
if (event.type == SDL_EVENT_GAMEPAD_ADDED) {
    if (!gamepad) {
        gamepad = SDL_OpenGamepad(event.gdevice.which);
        if (gamepad) {
            std::println("Gamepad connected: {}", SDL_GetGamepadName(gamepad));
        }
    }
}
else if (event.type == SDL_EVENT_GAMEPAD_REMOVED) {
    if (gamepad && SDL_GetGamepadID(gamepad) == event.gdevice.which) {
        std::println("Gamepad disconnected");
        SDL_CloseGamepad(gamepad);
        gamepad = nullptr;
    }
}</code></pre>

            <p><strong>Note:</strong> Keyboard input remains active even when a controller is connected, allowing seamless switching between input methods.</p>

            <h3>Joypad Interrupt (Optional)</h3>
            <p>The Game Boy can trigger an interrupt when buttons are pressed (bit 4 of IE register). This allows games to wake from HALT mode on button press. Most games poll JOYP directly instead of using interrupts.</p>
        </section>

        <section>
            <h2>Part 2: PPU Rendering System</h2>
            
            <h3>Overview</h3>
            <p>The Game Boy PPU (Picture Processing Unit) is responsible for rendering graphics. It supports three rendering layers:</p>
            <ul>
                <li><strong>Background:</strong> A scrollable 256×256 pixel tilemap</li>
                <li><strong>Window:</strong> A non-scrollable overlay layer (used for HUDs and menus)</li>
                <li><strong>Sprites/Objects:</strong> Movable 8×8 or 8×16 pixel graphics (40 total, 10 per scanline)</li>
            </ul>
            
            <h3>Display Specifications</h3>
            <ul>
                <li><strong>Resolution:</strong> 160×144 pixels</li>
                <li><strong>Colors:</strong> 4 shades of gray (2 bits per pixel)</li>
                <li><strong>Refresh Rate:</strong> ~59.7 Hz (154 scanlines, 456 cycles each)</li>
                <li><strong>Tile-Based:</strong> All graphics use 8×8 pixel tiles</li>
            </ul>
        </section>

        <section>
            <h3>PPU State Machine</h3>
            
            <p>The PPU cycles through 4 modes per scanline:</p>
            
            <pre><code>Mode 2 (OAM Search)  → Mode 3 (Drawing) → Mode 0 (H-Blank)
     80 cycles           172 cycles          204 cycles
     Total: 456 cycles per scanline</code></pre>
            
            <p>After 144 visible scanlines, it enters <strong>Mode 1 (V-Blank)</strong> for 10 scanlines (lines 144-153).</p>
            
            <h4>Mode Responsibilities</h4>
            <ul>
                <li><strong>Mode 2 (OAM Search):</strong> Scan OAM memory for sprites visible on current scanline</li>
                <li><strong>Mode 3 (Drawing):</strong> Render background, window, and sprites to framebuffer</li>
                <li><strong>Mode 0 (H-Blank):</strong> Horizontal blanking period (CPU can access VRAM)</li>
                <li><strong>Mode 1 (V-Blank):</strong> Vertical blanking period (frame complete, CPU has full VRAM access)</li>
            </ul>
        </section>

        <section>
            <h3>Background Rendering</h3>
            
            <p>The background layer is a 32×32 grid of tile indices (256×256 pixels total), viewable through a 160×144 pixel window controlled by scroll registers SCX and SCY.</p>
            
            <h4>Tile Data Format</h4>
            <p>Each tile is 8×8 pixels stored as 16 bytes:</p>
            <pre><code>Bytes 0-1:  Row 0 (byte0 = low bits, byte1 = high bits)
Bytes 2-3:  Row 1
... and so on

For each pixel:
color = (byte2[bit] << 1) | byte1[bit]  // 2-bit color (0-3)</code></pre>
            
            <h4>Rendering Algorithm</h4>
            <ol>
                <li>Apply scroll offset: <code>pixel_x = (x + SCX) & 0xFF</code>, <code>pixel_y = (scanline + SCY) & 0xFF</code></li>
                <li>Determine which tile: <code>tile_x = pixel_x / 8</code>, <code>tile_y = pixel_y / 8</code></li>
                <li>Read tile index from tile map at <code>tile_map_base + tile_y * 32 + tile_x</code></li>
                <li>Calculate tile address (handling signed/unsigned modes)</li>
                <li>Read 2 bytes for the current row</li>
                <li>Extract 2-bit color from the appropriate bit position</li>
                <li>Apply BGP palette to map color 0-3 to actual shade</li>
            </ol>
            
            <pre><code>uint8_t PPU::get_tile_pixel(uint8_t pixel_x, uint8_t pixel_y, 
                            uint16_t tile_map_base, uint16_t tile_data_base,
                            bool signed_tile_ids, uint8_t palette, 
                            Memory& memory)
{
    uint8_t tile_y = pixel_y / 8;
    uint8_t tile_x = pixel_x / 8;
    uint16_t tile_map_addr = tile_map_base + tile_y * 32 + tile_x;
    
    uint8_t tile_id = memory.read(tile_map_addr);
    
    // Calculate tile address (signed or unsigned mode)
    uint16_t tile_addr;
    if (signed_tile_ids) {
        int8_t signed_id = static_cast&lt;int8_t&gt;(tile_id);
        tile_addr = tile_data_base + (signed_id + 128) * 16;
    } else {
        tile_addr = tile_data_base + tile_id * 16;
    }
    
    // Get pixel position within tile
    uint8_t tile_pixel_y = pixel_y % 8;
    uint8_t tile_pixel_x = pixel_x % 8;
    
    // Read tile row data
    uint16_t tile_row_addr = tile_addr + tile_pixel_y * 2;
    uint8_t byte1 = memory.read(tile_row_addr);
    uint8_t byte2 = memory.read(tile_row_addr + 1);
    
    // Extract color (bit 7 = leftmost pixel)
    int bit_pos = 7 - tile_pixel_x;
    uint8_t color_id = ((byte2 >> bit_pos) & 1) << 1 | 
                       ((byte1 >> bit_pos) & 1);
    
    // Apply palette
    return (palette >> (color_id * 2)) & 0x03;
}</code></pre>
        </section>

        <section>
            <h3>Window Layer</h3>
            
            <p>The window is a second background layer that overlays the regular background. It doesn't scroll and is positioned via WX/WY registers.</p>
            
            <h4>Key Differences from Background</h4>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Background</th>
                        <th>Window</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Scrolling</td>
                        <td>Uses SCX/SCY</td>
                        <td>No scrolling</td>
                    </tr>
                    <tr>
                        <td>Position</td>
                        <td>Anywhere via scroll</td>
                        <td>WX/WY on screen</td>
                    </tr>
                    <tr>
                        <td>Priority</td>
                        <td>Drawn first</td>
                        <td>Covers background</td>
                    </tr>
                    <tr>
                        <td>Tile Map</td>
                        <td>LCDC bit 3</td>
                        <td>LCDC bit 6</td>
                    </tr>
                </tbody>
            </table>
            
            <h4>Window Line Counter</h4>
            <p>The window has an internal line counter separate from LY:</p>
            <ul>
                <li>Starts at 0 when window first becomes visible</li>
                <li>Increments each scanline the window is actually rendered</li>
                <li>Does NOT reset mid-frame</li>
                <li>Resets to 0 at the start of each frame</li>
            </ul>
            
            <h4>Position Calculation</h4>
            <pre><code>// Window is visible when:
bool window_visible = (LCDC & WINDOW_ENABLE) && 
                      (scanline >= WY) && 
                      (x >= (WX - 7));

// Window coordinates (no scrolling):
uint8_t window_x = x - (WX - 7);
uint8_t window_y = window_line_counter;</code></pre>
            
            <p><strong>Note:</strong> WX is offset by 7, so WX=7 means window at screen column 0.</p>
        </section>

        <section>
            <h3>Sprite/Object Rendering</h3>
            
            <p>Sprites are movable 8×8 or 8×16 pixel graphics stored in OAM (Object Attribute Memory) at 0xFE00-0xFE9F.</p>
            
            <h4>OAM Structure</h4>
            <p>40 sprites total, each sprite is 4 bytes:</p>
            <pre><code>Byte 0: Y Position (actual position = Y - 16)
Byte 1: X Position (actual position = X - 8)
Byte 2: Tile Index
Byte 3: Attributes:
        Bit 7: Priority (0=above BG, 1=behind BG colors 1-3)
        Bit 6: Y Flip
        Bit 5: X Flip
        Bit 4: Palette (0=OBP0, 1=OBP1)</code></pre>
            
            <h4>OAM Search Process</h4>
            <p>During Mode 2, scan all 40 OAM entries for sprites intersecting the current scanline:</p>
            
            <pre><code>void PPU::scan_oam(Memory& memory)
{
    visible_sprite_count = 0;
    
    uint8_t lcdc = memory.read(LCDC);
    if (!(lcdc & LCDC_OBJ_ENABLE)) return;
    
    int sprite_height = (lcdc & LCDC_OBJ_SIZE) ? 16 : 8;
    
    for (int i = 0; i < 40; i++)
    {
        uint16_t sprite_addr = 0xFE00 + (i * 4);
        uint8_t y = memory.read(sprite_addr);
        
        // Skip off-screen sprites
        if (y == 0 || y >= 160) continue;
        
        // Check if sprite intersects scanline
        int sprite_top = y - 16;
        int sprite_bottom = sprite_top + sprite_height;
        
        if (scanline >= sprite_top && scanline < sprite_bottom)
        {
            // Store sprite data
            visible_sprites[visible_sprite_count++] = {
                y, x, tile, attributes, i
            };
            
            // Hardware limit: 10 sprites per scanline
            if (visible_sprite_count >= 10) break;
        }
    }
}</code></pre>
            
            <h4>Sprite Pixel Rendering</h4>
            <p>Key features to handle:</p>
            <ul>
                <li><strong>Position:</strong> Sprite coordinates offset by (X-8, Y-16)</li>
                <li><strong>Flipping:</strong> X flip: <code>pixel_x = 7 - pixel_x</code>, Y flip: <code>pixel_y = (height-1) - pixel_y</code></li>
                <li><strong>8×16 Mode:</strong> Use tile index & 0xFE for top, (tile & 0xFE) + 1 for bottom</li>
                <li><strong>Transparency:</strong> Color 0 is always transparent for sprites</li>
                <li><strong>Tile Data:</strong> Sprites always use 0x8000 base address (unsigned)</li>
                <li><strong>Palettes:</strong> OBP0 or OBP1 selected by attribute bit 4</li>
            </ul>
            
            <pre><code>int PPU::get_sprite_pixel(const Sprite& sprite, int screen_x, 
                                  Memory& memory)
{
    // Check if pixel is within sprite bounds
    int sprite_left = sprite.x - 8;
    if (screen_x < sprite_left || screen_x >= sprite_left + 8)
        return -1; // Transparent
    
    int pixel_x = screen_x - sprite_left;
    int pixel_y = scanline - (sprite.y - 16);
    
    // Handle flipping
    if (sprite.attributes & SPRITE_FLIP_X)
        pixel_x = 7 - pixel_x;
    if (sprite.attributes & SPRITE_FLIP_Y)
        pixel_y = (sprite_height - 1) - pixel_y;
    
    // Handle 8×16 mode
    uint8_t tile_index = sprite.tile_index;
    if (sprite_height == 16) {
        if (pixel_y >= 8) {
            tile_index = (sprite.tile_index & 0xFE) + 1;
            pixel_y -= 8;
        } else {
            tile_index = sprite.tile_index & 0xFE;
        }
    }
    
    // Read tile data (always from 0x8000)
    uint16_t tile_addr = 0x8000 + (tile_index * 16);
    uint16_t row_addr = tile_addr + (pixel_y * 2);
    uint8_t byte1 = memory.read(row_addr);
    uint8_t byte2 = memory.read(row_addr + 1);
    
    // Extract color
    int bit_pos = 7 - pixel_x;
    uint8_t color_id = ((byte2 >> bit_pos) & 1) << 1 | 
                       ((byte1 >> bit_pos) & 1);
    
    if (color_id == 0) return -1; // Transparent
    
    // Apply sprite palette
    uint8_t palette = (sprite.attributes & SPRITE_PALETTE) 
                      ? memory.read(OBP1) : memory.read(OBP0);
    return (palette >> (color_id * 2)) & 0x03;
}</code></pre>
        </section>

        <section>
            <h3>Priority System</h3>
            
            <p>The final pixel color is determined by layering order and priority rules:</p>
            
            <h4>Sprite-to-Sprite Priority</h4>
            <ul>
                <li>Lower OAM index = higher priority (sprite 0 is on top)</li>
                <li>First non-transparent sprite pixel wins</li>
                <li>Scan sprites in OAM order during rendering</li>
            </ul>
            
            <h4>Sprite-to-Background Priority</h4>
            <p>Controlled by attribute bit 7 (SPRITE_PRIORITY):</p>
            <ul>
                <li><strong>Bit clear (0):</strong> Sprite above background (always visible if not transparent)</li>
                <li><strong>Bit set (1):</strong> Sprite behind BG colors 1-3 (only visible through BG color 0)</li>
            </ul>
            
            <pre><code>// Priority resolution in render_scanline
uint8_t final_color;

if (sprite_color == -1) {
    // No sprite, use background
    final_color = bg_color;
}
else if (sprite_priority & SPRITE_PRIORITY) {
    // Sprite behind BG colors 1-3
    final_color = (bg_color == 0) ? sprite_color : bg_color;
}
else {
    // Sprite above BG
    final_color = sprite_color;
}</code></pre>
        </section>

        <section>
            <h3>Registers and Memory</h3>
            
            <h4>LCD Control (LCDC - 0xFF40)</h4>
            <ul>
                <li><strong>Bit 7:</strong> LCD Enable</li>
                <li><strong>Bit 6:</strong> Window tile map (0=9800-9BFF, 1=9C00-9FFF)</li>
                <li><strong>Bit 5:</strong> Window enable</li>
                <li><strong>Bit 4:</strong> BG/Window tile data (0=8800-97FF signed, 1=8000-8FFF unsigned)</li>
                <li><strong>Bit 3:</strong> BG tile map (0=9800-9BFF, 1=9C00-9FFF)</li>
                <li><strong>Bit 2:</strong> Sprite size (0=8×8, 1=8×16)</li>
                <li><strong>Bit 1:</strong> Sprite enable</li>
                <li><strong>Bit 0:</strong> BG/Window enable</li>
            </ul>
            
            <h4>Position Registers</h4>
            <ul>
                <li><strong>SCY (0xFF42):</strong> Background scroll Y</li>
                <li><strong>SCX (0xFF43):</strong> Background scroll X</li>
                <li><strong>LY (0xFF44):</strong> Current scanline (0-153)</li>
                <li><strong>WY (0xFF4A):</strong> Window Y position</li>
                <li><strong>WX (0xFF4B):</strong> Window X position + 7</li>
            </ul>
            
            <h4>Palettes</h4>
            <ul>
                <li><strong>BGP (0xFF47):</strong> Background palette</li>
                <li><strong>OBP0 (0xFF48):</strong> Sprite palette 0</li>
                <li><strong>OBP1 (0xFF49):</strong> Sprite palette 1</li>
            </ul>
            
            <p>Palette format (2 bits per color):</p>
            <pre><code>Bits 7-6: Color 3 (darkest)
Bits 5-4: Color 2
Bits 3-2: Color 1
Bits 1-0: Color 0 (lightest)</code></pre>
        </section>

        <section>
            <h2>Implementation Summary</h2>
            
            <h3>Data Structures</h3>
            <pre><code>// Input
struct Memory {
    uint8_t joypad_state;  // Bits 0-3: A,B,Sel,Start; 4-7: R,L,U,D
};

// Rendering
struct Sprite {
    uint8_t y, x;
    uint8_t tile_index;
    uint8_t attributes;
    uint8_t oam_index;
};

struct PPU {
    std::array&lt;uint8_t, 160*144&gt; framebuffer;
    std::array&lt;uint8_t, 160*144*4&gt; rgba_buffer;
    std::array&lt;Sprite, 10&gt; visible_sprites;
    
    PPUMode mode;
    int scanline;
    int window_line_counter;
    int visible_sprite_count;
};</code></pre>
            
            <h3>Code Size</h3>
            <ul>
                <li><strong>Input Handling:</strong> ~100 lines (SDL keyboard + gamepad mapping + memory interface)</li>
                <li><strong>Background Rendering:</strong> ~80 lines</li>
                <li><strong>Window Rendering:</strong> ~50 lines (refactored with shared helper)</li>
                <li><strong>Sprite Rendering:</strong> ~190 lines (OAM scan + rendering + priority)</li>
                <li><strong>SDL Integration:</strong> ~100 lines (initialization, main loop, texture updates)</li>
                <li><strong>Total:</strong> ~520 lines excluding PPU state management</li>
            </ul>
            
            <h3>Performance</h3>
            <p>With complete input and rendering implementation, Tetris executes <strong>6.4+ million instructions</strong> before hitting unimplemented CPU instructions, demonstrating proper frame rendering, timing, and input handling.</p>
        </section>

        <section>
            <h2>Part 3: SDL Integration</h2>
            
            <h3>Overview</h3>
            <p>SDL3 is used to create a window, handle input events, and display the rendered framebuffer. The integration involves creating a texture that's updated each frame with the PPU's output.</p>
            
            <h3>Initialization</h3>
            <pre><code>// Initialize SDL with video and gamepad
SDL_Init(SDL_INIT_VIDEO | SDL_INIT_GAMEPAD);

// Create window (scaled up from 160x144)
SDL_Window* window = SDL_CreateWindow(
    "Game Boy Emulator",
    SCREEN_WIDTH * SCALE,  // 160 * 4 = 640
    SCREEN_HEIGHT * SCALE, // 144 * 4 = 576
    0
);

// Create renderer
SDL_Renderer* renderer = SDL_CreateRenderer(window, nullptr);

// Create texture for Game Boy screen
SDL_Texture* screen_texture = SDL_CreateTexture(
    renderer,
    SDL_PIXELFORMAT_RGBA32,
    SDL_TEXTUREACCESS_STREAMING,
    SCREEN_WIDTH,  // 160
    SCREEN_HEIGHT  // 144
);</code></pre>
            
            <h3>Main Loop</h3>
            <p>The main loop handles events, runs one frame of emulation, and updates the screen:</p>
            
            <pre><code>while (!quit && gameboy.running)
{
    // Handle SDL events
    SDL_Event event;
    while (SDL_PollEvent(&event))
    {
        if (event.type == SDL_EVENT_QUIT)
            quit = true;
        else if (event.type == SDL_EVENT_GAMEPAD_BUTTON_DOWN || 
                 event.type == SDL_EVENT_GAMEPAD_BUTTON_UP)
            handle_gamepad_input(event, gameboy);
        else
            handle_input(event, gameboy);  // Keyboard
    }
    
    // Run one frame of emulation (~70224 cycles)
    gameboy.step_frame();
    
    // Update screen texture if frame is ready
    if (gameboy.ppu.frame_ready)
    {
        SDL_UpdateTexture(
            screen_texture,
            nullptr,
            gameboy.ppu.rgba_buffer.data(),  // PPU's RGBA output
            SCREEN_WIDTH * 4                  // Pitch (bytes per row)
        );
        gameboy.ppu.frame_ready = false;
    }
    
    // Render to window
    SDL_RenderClear(renderer);
    SDL_RenderTexture(renderer, screen_texture, nullptr, nullptr);
    SDL_RenderPresent(renderer);
}</code></pre>
            
            <h3>Framebuffer Format</h3>
            <p>The PPU outputs an RGBA buffer that SDL can directly display:</p>
            
            <pre><code>// In PPU struct
std::array&lt;uint8_t, 160*144*4&gt; rgba_buffer;  // R,G,B,A for each pixel

// Converting Game Boy colors to RGBA
const uint32_t GB_PALETTE[4] = {
    0xFFFFFFFF,  // Color 0: White
    0xFFAAAAAA,  // Color 1: Light gray
    0xFF555555,  // Color 2: Dark gray
    0xFF000000   // Color 3: Black
};

// During rendering
for (int y = 0; y < 144; y++) {
    for (int x = 0; x < 160; x++) {
        uint8_t gb_color = framebuffer[y * 160 + x];
        uint32_t rgba = GB_PALETTE[gb_color];
        
        int pixel_offset = (y * 160 + x) * 4;
        rgba_buffer[pixel_offset + 0] = (rgba >> 24) & 0xFF;  // R
        rgba_buffer[pixel_offset + 1] = (rgba >> 16) & 0xFF;  // G
        rgba_buffer[pixel_offset + 2] = (rgba >> 8) & 0xFF;   // B
        rgba_buffer[pixel_offset + 3] = rgba & 0xFF;          // A
    }
}</code></pre>
            
            <h3>Scaling</h3>
            <p>Since 160×144 is very small on modern displays, the window is typically scaled up. SDL handles the scaling automatically - we create the texture at native resolution (160×144) but create the window at 4× scale (640×576).</p>
            
            <h3>Frame Timing</h3>
            <p>To maintain ~59.7 Hz (Game Boy's refresh rate), we can implement frame limiting:</p>
            
            <pre><code>const double target_frame_time = 1000.0 / 59.7;  // ~16.75 ms
Uint64 frame_start = SDL_GetTicks();

// ... run frame and render ...

// Delay to maintain target frame rate
double elapsed = SDL_GetTicks() - frame_start;
if (elapsed < target_frame_time) {
    SDL_Delay(target_frame_time - elapsed);
}</code></pre>
        </section>

        <section>
            <h2>What's Missing?</h2>
            
            <h4>Input:</h4>
            <ul>
                <li>Joypad interrupt generation (most games poll instead)</li>
            </ul>
            
            <h4>Rendering:</h4>
            <ul>
                <li>Variable Mode 3 timing (currently fixed at 172 cycles)</li>
                <li>Sprite X-coordinate priority edge cases</li>
                <li>Hardware bugs (STAT interrupt blocking, OAM corruption)</li>
                <li>Game Boy Color features (color palettes, per-tile attributes)</li>
            </ul>
            
            <p>These features are only needed for demo scene programs that exploit hardware quirks or GBC games.</p>
        </section>

        <section>
            <h2>Testing Results</h2>
            
            <p>Testing with <strong>Tetris (JUE) V1.1</strong>:</p>
            <ul>
                <li>✅ Input handling works</li>
                <li>✅ Background rendering works (game field)</li>
                <li>✅ Window rendering works (score/level display)</li>
                <li>✅ Sprite rendering works (falling pieces)</li>
                <li>✅ PPU timing correct (proper V-Blank interrupts)</li>
                <li>✅ No crashes or rendering artifacts</li>
                <li>⚠️ Game stops at missing CPU instruction (SUB opcode 0xD6)</li>
            </ul>
            
            <p>Both input and rendering systems are fully functional - the emulator just needs remaining CPU instructions implemented!</p>
        </section>

        <section>
            <h2>Full Implementation</h2>
            <p>
                The complete code for input handling, PPU rendering (background, window, sprites), and SDL integration with gamepad support can be found on the 
                <a href="https://github.com/lasiqueira/gbemu/tree/rendering" target="_blank">rendering branch</a>.
            </p>
        </section>
        </article>
    </main>

    <nav class="page-nav bottom">
        <a href="instructions_part2.html">← Instructions - Part 2</a>
        <a href="index.html">Index →</a>
    </nav>

    <footer>
        <p><a href="https://github.com/lasiqueira/gbemu">View on GitHub</a></p>
    </footer>
</body>
</html>
