<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implementing CPU Instructions - Game Boy Emulator</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>Game Boy Emulator</h1>
        <p>A C++ Game Boy emulator development journey</p>
    </header>

    <nav class="page-nav">
        <a href="cpu_and_memory.html">← CPU & Memory</a>
        <span class="current">Instructions</span>
        <span class="disabled">Next →</span>
    </nav>

    <main>
        <article class="content">
        <h2>Implementing CPU Instructions</h2>
        <p><em>Building the instruction set one opcode at a time</em></p>

        <section>
            <h2>The Journey Begins</h2>
            <p>With the CPU and memory framework in place, we can now start implementing actual Game Boy instructions. The approach is simple: run the emulator with a real ROM (in this case, Tetris), and implement each instruction as we encounter it.</p>

            <h3>First Steps</h3>
            <p>Starting the emulator with Tetris, we immediately hit our first unimplemented instruction:</p>
            
            <pre><code>Game Boy Emulator
ROM loaded: 32768 bytes
Starting emulation...

Unimplemented instruction: 0xC3 at PC: 0x0101

Addr  Instruction           Flags     Len  Cycles
----  --------------------  --------  ---  ------
0101  JP $0150              -           3  16

CPU State:
A: 0000  B: 0000  C: 0000  D: 0000  E: 0000  H: 0000  L: 0000  SP: FFFE  PC: 0101
Flags: Z=false N=false H=false C=false</code></pre>

            <p>The very first instruction Tetris wants to execute is <code>JP $0150</code> - an unconditional jump to address 0x0150. This makes sense; the Game Boy ROM header occupies addresses 0x0100-0x014F, so games typically jump past it to start their actual code.</p>

            <h3>Understanding Instructions</h3>
            <p>If you have some familiarity with any assembly language family (x86, ARM, 6502, etc.), you'll find many Game Boy instructions similar to what you already know. Concepts like jumps, loads, arithmetic operations, and stack manipulation are universal across most CPU architectures. You can often implement instructions based on this prior experience.</p>

            <p>However, if you have no experience with assembly language, don't worry! The <a href="https://rgbds.gbdev.io/docs/v1.0.1/gbz80.7" target="_blank">Game Boy CPU instruction set documentation</a> (part of Pan Docs) is an excellent resource. It explains what each instruction does, how it affects flags, how many cycles it takes, and what operands it expects. This documentation will be your guide for implementing each opcode correctly.</p>
        </section>

        <section>
            <h2>Implementing JP (Jump)</h2>
            
            <h3>The Unconditional Jump</h3>
            <p>The <code>JP a16</code> instruction (opcode 0xC3) is straightforward: set the program counter to the 16-bit address specified in the next two bytes.</p>

            <pre><code>// cpu.h
int jp_a16(uint16_t addr, bool condition = true);

// cpu.cpp
int CPU::jp_a16(uint16_t addr, bool condition) {
    if (condition) {
        pc = addr;
        return 16; // JP takes 16 cycles if taken
    } else {
        pc += 3; // Move past the instruction and operands
        return 12; // JP takes 12 cycles if not taken
    }
}</code></pre>

            <p>Note that we added a <code>condition</code> parameter with a default value of <code>true</code>. This is forward-thinking design - the Game Boy has both unconditional jumps (<code>JP a16</code>) and conditional jumps (<code>JP Z, a16</code>, <code>JP NZ, a16</code>, etc.). By adding the condition parameter now, we can reuse this function for all jump variants.</p>

            <h3>Extending to Conditional Jumps</h3>
            <p>The Game Boy has five conditional jump instructions, all checking the flag register:</p>
            <ul>
                <li><code>JP NZ, a16</code> (0xC2) - Jump if Zero flag is NOT set</li>
                <li><code>JP Z, a16</code> (0xCA) - Jump if Zero flag is set</li>
                <li><code>JP NC, a16</code> (0xD2) - Jump if Carry flag is NOT set</li>
                <li><code>JP C, a16</code> (0xDA) - Jump if Carry flag is set</li>
            </ul>

            <p>Adding these to the switch case is straightforward:</p>

            <pre><code>int CPU::execute_instruction(Memory& memory) {
    uint8_t opcode = memory.read(pc);
    switch (opcode) {
        case 0x00: return nop();
        case 0xC2: return jp_a16(memory.read_word(pc + 1), !get_flag(af.low, FLAG_ZERO));
        case 0xC3: return jp_a16(memory.read_word(pc + 1));
        case 0xCA: return jp_a16(memory.read_word(pc + 1), get_flag(af.low, FLAG_ZERO));
        case 0xD2: return jp_a16(memory.read_word(pc + 1), !get_flag(af.low, FLAG_CARRY));
        case 0xDA: return jp_a16(memory.read_word(pc + 1), get_flag(af.low, FLAG_CARRY));
        default:
            unimplemented_instruction(opcode, memory.rom);
            return -1;
    }
}</code></pre>

            <p>With one function, we've implemented 5 opcodes! This is the power of looking for patterns in the instruction set.</p>

            <h3>Testing the Jump</h3>
            <p>Running the emulator again, we successfully execute the jump and encounter the next instruction:</p>

            <pre><code>Game Boy Emulator
ROM loaded: 32768 bytes
Starting emulation...

Unimplemented instruction: 0xAF at PC: 0x0150

Addr  Instruction           Flags       Len  Cycles
----  --------------------  --------    ---  ------
0150  XOR A                 Z,0,0,0       1  4

CPU State:
A: 0000  B: 0000  C: 0000  D: 0000  E: 0000  H: 0000  L: 0000  SP: FFFE  PC: 0150
Flags: Z=false N=false H=false C=false</code></pre>

            <p>Progress! The PC has moved from 0x0101 to 0x0150, confirming our jump worked. Now we need to implement <code>XOR A</code>.</p>
        </section>

        <section>
            <h2>Implementing XOR</h2>
            
            <h3>Understanding XOR A</h3>
            <p>The instruction <code>XOR A</code> performs a bitwise XOR between register A and itself. Since any value XORed with itself is zero, this is a common idiom for clearing register A to zero. It's faster and shorter than <code>LD A, 0</code>.</p>

            <p>However, the Game Boy has XOR instructions for all registers:</p>
            <ul>
                <li>XOR B, C, D, E, H, L (opcodes 0xA8-0xAD) - XOR with register</li>
                <li>XOR (HL) (0xAE) - XOR with value at memory address HL</li>
                <li>XOR A (0xAF) - XOR with register A (clear to zero)</li>
                <li>XOR n8 (0xEE) - XOR with immediate byte</li>
            </ul>

            <h3>A Generic XOR Function</h3>
            <p>Rather than implementing separate functions for each variant, we can create one generic function that handles all cases:</p>

            <pre><code>// cpu.h
int xor_a(uint8_t value, int extra_pc = 0, int extra_cycles = 0);

// cpu.cpp
int CPU::xor_a(uint8_t value, int extra_pc, int extra_cycles) {
    af.high ^= value;
    
    // Set flags
    set_flag(af.low, FLAG_ZERO, af.high == 0);
    set_flag(af.low, FLAG_SUBTRACT, false);
    set_flag(af.low, FLAG_HALF_CARRY, false);
    set_flag(af.low, FLAG_CARRY, false);
    
    pc += 1 + extra_pc; // Move past the instruction and any extra bytes
    return 4 + extra_cycles; // Base cycles plus any extra
}</code></pre>

            <p>The key insight here is using <code>extra_pc</code> and <code>extra_cycles</code> parameters:</p>
            <ul>
                <li>Register XOR: no extra bytes, no extra cycles</li>
                <li>Memory XOR (HL): no extra bytes, but +4 cycles for memory read</li>
                <li>Immediate XOR: +1 byte for the immediate value, +4 cycles</li>
            </ul>

            <h3>Adding All XOR Variants</h3>
            <pre><code>case 0xA8: return xor_a(bc.high);                         // XOR B
case 0xA9: return xor_a(bc.low);                          // XOR C
case 0xAA: return xor_a(de.high);                         // XOR D
case 0xAB: return xor_a(de.low);                          // XOR E
case 0xAC: return xor_a(hl.high);                         // XOR H
case 0xAD: return xor_a(hl.low);                          // XOR L
case 0xAE: return xor_a(memory.read(hl.pair), 0, 4);     // XOR (HL)
case 0xAF: return xor_a(af.high);                         // XOR A
case 0xEE: return xor_a(memory.read(pc + 1), 1, 4);      // XOR n8</code></pre>

            <p>With one function, we've implemented 9 opcodes! We're now at 15 opcodes total (NOP + 5 JPs + 9 XORs).</p>
        </section>

        <section>
            <h2>The Pattern Emerges</h2>
            <p>As we continue implementing instructions, a pattern becomes clear:</p>
            
            <ol>
                <li><strong>Run the emulator</strong> - Let it tell you what instruction it needs</li>
                <li><strong>Identify the family</strong> - Is this instruction one of many similar ones?</li>
                <li><strong>Design generically</strong> - Create functions that handle multiple opcodes</li>
                <li><strong>Implement them all</strong> - Add all related opcodes to the switch case</li>
                <li><strong>Test</strong> - Run again and move to the next instruction</li>
            </ol>

            <p>This approach is efficient and ensures we only implement what's actually needed for our target ROM (Tetris), while still writing reusable code that works for other games later.</p>

            <h3>Next Steps</h3>
            <p>Following this pattern, we'll continue implementing instruction families:</p>
            <ul>
                <li><strong>LD instructions</strong> - Loading data between registers and memory</li>
                <li><strong>INC/DEC</strong> - Incrementing and decrementing values</li>
                <li><strong>Arithmetic</strong> - ADD, SUB, CP (compare)</li>
                <li><strong>Stack operations</strong> - PUSH, POP, CALL, RET</li>
                <li><strong>Bit operations</strong> - BIT, SET, RES (CB-prefixed)</li>
            </ul>

            <p>By the time Tetris runs, we'll have implemented roughly 80-100 opcodes - about 35-40% of the full instruction set. But the framework we're building makes adding the remaining instructions straightforward when needed.</p>
        </section>
        </article>
    </main>

    <footer>
        <p>Part of the Game Boy Emulator project | <a href="index.html">Home</a></p>
    </footer>
</body>
</html>
